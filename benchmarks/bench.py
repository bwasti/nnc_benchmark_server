import time
import numpy as np


class Timer:
    def __init__(self):
        pass

    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, type, value, traceback):
        self.end = time.time()

    def count(self):
        return self.end - self.start


def bench_run(f, inp_gen, seconds, warmup_pct):
    inps = inp_gen()
    for _ in range(3):
        f(*inps)
    with Timer() as t:
        f(*inps)
    warmup_s = min(1, 1.0 * warmup_pct / 100) * seconds
    warmup_iters = int(warmup_s / t.count())
    for _ in range(warmup_iters):
        f(*inps)
    iters = int(seconds / t.count())
    assert iters > 0, (
        "Cannot run this function in less than "
        + str(seconds)
        + " seconds... Call `bench` with larger value for `seconds`"
    )
    with Timer() as t:
        for _ in range(iters):
            f(*inps)
    return 1000000 * t.count() / iters


# Benchmarks a function with inputs generated by inp_gen
# Attempts to run a benchmark loop `runs` times in `seconds`
# Returns the mean, stddev min and max of the runs in microseconds
def bench(f, inp_gen=lambda: (), seconds=1, runs=5, warmup_pct=10):
    results = []
    for _ in range(runs):
        results.append(bench_run(f, inp_gen, seconds / runs, warmup_pct))
    mean = np.mean(results)
    stddev = np.std(results)
    min_ = min(results)
    max_ = max(results)
    return mean, stddev, min_, max_


import json


def json_bench(name, f, inp, **kwargs):
    mean, stddev, min_, max_ = bench(f, inp, **kwargs)
    return json.dumps(
        {"name": name, "mean": mean, "stddev": stddev, "min": min_, "max": max_}
    )


if __name__ == "__main__":
    import sys, os

    if len(sys.argv) < 2:
        print("Usage: python bench.py [cmd]")
        exit(1)
    cmd = " ".join(sys.argv[1:])
    print("Benchmarking " + cmd)

    def f():
        os.system(cmd)

    print(bench(f))
